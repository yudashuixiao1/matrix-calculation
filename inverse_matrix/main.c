#include<stdlib.h>
#include<stdio.h>
//#include<conio.h>
//#include<math.h>

//#define dim 2
#define size 200
int inv_matrix(int n,float a[size][size],float a_inv[size][size]);


// inverse matrix
int inv_matrix(int n,float a[size][size],float a_inv[size][size]){

        int i,j,k;
        float ratio;
		 /* Augmenting Identity Matrix of Order n n阶增广单位矩阵*/
		 for(i=0;i<n;i++)
		 {
			  for(j=0;j<n;j++)
			  {
				   if(i==j)
				   {
				    	a[i][j+n] = 1;
				   }
				   else
				   {
				    	a[i][j+n] = 0;
				   }
			  }
		 }
		 /* Applying Gauss Jordan Elimination */
		 for(i=0;i<n;i++)
		 {
			  if(a[i][i] == 0.0)
			  {
				   exit(0);
			  }
			  for(j=0;j<n;j++)
			  {
				   if(i!=j)
				   {
					    ratio = a[j][i]/a[i][i];
					    for(k=1;k<=2*n;k++)
					    {
					     	a[j][k] = a[j][k] - ratio*a[i][k];
					    }
				   }
			  }
		 }
		 /* Row Operation to Make Principal Diagonal to 1 */
		 for(i=0;i<n;i++)
		 {
			  for(j=n;j<2*n;j++)
			  {
			   	a[i][j] = a[i][j]/a[i][i];
			   	a_inv[i][j] = a[i][j];
			  }
		 }
		 return a_inv;
}


//solution
int main (){
int n = 11;
float a_inv[size][size];

float a[size][size] =
{{0.00583690322580645,-0.00422400000000000,0,0,0,0,0,0,0,0,0},
{-0.00422400000000000,0.00522400000000000,-0.00100000000000000,0,0,0,0,0,0,0,0},
{0,-0.00100000000000000,0.00399111111111111,-0.000111111111111111,0,-0.00288000000000000,0,0,0,0,0},
{0,0,-0.000111111111111111,0.00433511111111111,-0.00422400000000000,0,0,0,0,0,0},
{0,0,0,-0.00422400000000000,0.00583690322580645,0,0,0,0,0,-0.00161290322580645},
{0,0,0,0,-0.00161290322580645,9999999.99990976,0,0,0,-0.000161290322580645,0.00186443354838710},
{0,0,0,0,0,0,0.0291869313482217,-0.000200000000000000,-0.0288000000000000,0,0},
{0,0,0,0,0,-8.33333333333333e-05,-0.000200000000000000,0.00222555555555556,-0.00192000000000000,-2.22222222222222e-05,0},
{0,0,0,0,0,0,-0.0288000000000000,-0.00192000000000000,0.0596033333333333,-0.0288000000000000,0},
{0,0,0,0,0,0,0,-2.22222222222222e-05,-0.0288000000000000,0.0289835125448029,-0.000161290322580645},
{0,0,-0.00288000000000000,0,0,0.00305357433333333,0,-8.33333333333333e-05,0,0,-9.02400000000000e-05}};
/*
float b[dim][1] = {{-0.00106884424213353},{ -0.000348692601884063}, {0.000174265198850949}, {0.000174427403041040}, {-0.000174427403041040}, {-0.000149429667406232}, {2.41146505716419e-05}, {2.42126805918570e-05}, {2.52775723989535e-05}, {-0.000215358587964216}, {-2.48355314447163e-05}};
//float b[dim][1] = {-0.00106884424213353, -0.000348692601884063, 0.000174265198850949, 0.000174427403041040, -0.000174427403041040, -0.000149429667406232, 2.41146505716419e-05, 2.42126805918570e-05, 2.52775723989535e-05, -0.000215358587964216, -2.48355314447163e-05};
*/

//float a[size][size]={{1,2},{3,4}};


inv_matrix(n,a, a_inv);
printf("the inverse matrix is:\n");
		 for(int r=0;r<n;r++)
		 {
			    //  x[r][j] = 0;
			      for(int c=n;c<2*n;c++){
                   // x[r][j] = x[r][j] + (a_inv[r][c]*b[c][j]);  //
                    //printf("%e\t",x[r][j]);
                    printf("%e\t",a_inv[r][c]);
			      }

			    //printf("%e\t",x[r][j]);


			  printf("\n");
		 }

  return 0;
}
